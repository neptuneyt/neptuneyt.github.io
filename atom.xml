<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NeptuneYT&#39;s Blog</title>
  
  <subtitle>I think, therefore I am.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T11:56:32.827Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>neptuneyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Machine learning KFC</title>
    <link href="http://yoursite.com/2019/03/27/Machine-learning-KFC/"/>
    <id>http://yoursite.com/2019/03/27/Machine-learning-KFC/</id>
    <published>2019-03-27T09:27:56.000Z</published>
    <updated>2019-03-27T11:56:32.827Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="机器学习数据分析极简思路"><a href="#机器学习数据分析极简思路" class="headerlink" title="机器学习数据分析极简思路"></a>机器学习数据分析极简思路</h1><p>机器学习拥有庞大的知识体系，这里对机器学习的数据分析的整个思路和流程作最最简单的归纳。机器学习的步骤大致包括：<br><strong>1）理解和清理数据<br>2）特征选择<br>3）算法建模<br>4）测试评估模型</strong></p><h2 id="1）理解和清理数据"><a href="#1）理解和清理数据" class="headerlink" title="1）理解和清理数据"></a>1）理解和清理数据</h2><ul><li>理解数据<br>数据是机器学习大餐的原始食材，对数据分析起着至关重要的作用，理解原始数据的含义将有助于进一步分析。例如，甲基化图谱与年龄有着显著的相关性，而与性别关系不大，因此在数据分析中，对这两个特征（feature）需要区别对待。更好的理解方式是直接可视化某些数据，例如对于经典的鸢尾花数据集，可以通过python seaborn绘图包可视化各个特征（feature）之间的关系；对于大数据，则可以进行降维分析（PCOA、tSNE），理解数据组成主成分贡献度。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pip install seaborn</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">%matplotlib inline</span><br><span class="line">data=pd.read_csv(<span class="string">'iris.csv'</span>)    <span class="comment">#pandas 读入数据</span></span><br><span class="line">data.head(<span class="number">3</span>)    <span class="comment">#查看数据</span></span><br><span class="line">data.describe() <span class="comment">#数据基本统计</span></span><br><span class="line">sb.pairplot(data.dropna(),hue=<span class="string">'Species'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>鸢尾花数据组成<br><img src="/img/1.png" alt="32bc1a777af3001e5fc1dea42b93c0d1.png"><br>鸢尾花数据所有feature基本数理统计<br><img src="/img/2.png" alt="2b240766f89ac4edf021b4341265784a.png"><br>鸢尾花数据不同feature相互关系<br><img src="/img/3.png" alt="c6662ebd0cefd5735191807c454d879a.png"></p><ul><li>剔除异常值<br>清理数据的目的在于去除原始数据中的异常值和想办法处理缺失值，我们拿到手上的数据不可能尽善尽美，总有一些妖孽作祟，对于异常值我们应当剔除。举个栗子，假设在鸢尾花数据集中，有一个样本显示鸢尾花花瓣长度10m，其他诸如花瓣宽度、花萼长宽值都正常，可以脑补一下这是一朵什么样的花，那么这个样本显然应该剔除。</li><li>处理缺失值<br>缺失值在数据分析中很常见，总有一些样本观测值会因为这那的问题缺失，处理缺失值如果样本数量很大，而包含缺失值的样本又少，这个时候果断去掉这些样本，眼不见为净；如果因为样本有限或者缺失值太多，就要想办法补全缺失值（imputation）,常常利用逻辑回归建立模型，找出这些数据变化的规律，从而预测缺失值。如何合理推断和填回这些缺失值是一门大学问，哪种方法好，我也不敢妄言。</li></ul><h2 id="2）特征选择"><a href="#2）特征选择" class="headerlink" title="2）特征选择"></a>2）特征选择</h2><p>工业界广泛流传的一句话是：<strong>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已</strong>。由此可见，特征选择是机器学习的关键的关键。特征选择目的在于提取跟目标最为有效的信息，降低数据维度和计算成本，同时防止过拟合（overfitting，训练集特征用的太多太细，以致于在测试集中不适）。要知道，并不是特征越多，结果越好，没有严格意义上的特征累加效应，有时候好的几个特征胜于大量零碎的特征取得的效果。<br>在许多大数据挖掘竞赛中（国内的阿里天池和国外的kaggle平台），最复杂的过程莫过于特征工程建立阶段，大概占据了整个竞赛过程的70%的时间和精力，最终建立的模型的好坏大多也取决于特征工程建立的好坏。遗憾的是，特征工程不像模型建立的过程有着固定的套路，特征工程的建立凭借的更多的是经验，因此没有统一的方法。这里抛砖引玉介绍一些常见的办法，更为详细的内容请参考文后链接。<br><strong>a)特征过滤法</strong><br>比较简单，它按照特征的发散性或者相关性指标对各个特征进行评分，设定评分阈值或者待选择阈值的个数，选择合适特征。例如，我们可以简单的计算出每个feature的方差，方差越大说明这个feature在样本中变异大，即有区分性；而越小的（极端时方差为0），即表示在所有样本中一样，特征选择时则可不考虑这些特征。我们可以选择方差最大的前n个feature用于建模，这就是最为简单的方差筛选法。<br><strong>b)包装法</strong><br>根据目标函数，通常是预测效果评分，每次选择部分特征，或者排除部分特征。<br><strong>c)嵌入法</strong><br>则稍微复杂一点，它先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据权值系数从大到小来选择特征。类似于过滤法，但是它是通过机器学习训练来确定特征的优劣，而不是直接从特征的一些统计学指标来确定特征的优劣。<br>踩雷说：特征选择之后，需要从原始数据矩阵提取相应的特征重构矩阵，那么训练集和测试集的特征经过你各种变换之后，应当保持一一对应，类别和顺序在矩阵中都应该一致。<br>目前，已经有一些套路化的特征选择工具，例如python的FeatureSlector包，见链接。</p><h2 id="3）算法建模"><a href="#3）算法建模" class="headerlink" title="3）算法建模"></a>3）算法建模</h2><p>针对具体的问题，是分类问题？回归问题？还是其他？选择合适的模型，或者使用集成的算法模型。常见的算法模型包括：<br>对于回归问题：<br>a)线性回归（回归，LinearRegression）<br>b)岭回归（回归，Ridge）Ridge是线性回归加L2正则平方，以防止过拟合<br>c)拉索回归（Lasso），加入惩罚函数L1正则绝对值，防止过拟合<br>d)弹性网络回归（回归），同时使用L1和L2正则。<br>e)K近邻（回归和分类，KNeighborsRegressor）<br>f)决策树（回归和分类，DecisionTreeRegressor）<br>g)支持向量机（回归和分类，SVR）</p><p>对于分类问题：<br>a)支持向量机（回归和分类，SVC）<br>b决策树（回归与分类,DecisionTreeClassifier）<br>c)逻辑回归（分类,LogisticRegression)<br>d)LDA线性判别分析（分类,LinearDiscriminantAnalysis)<br>e)K近邻（分类,KNeighborsClassifier)<br>值得一提的是无论是分类还是回归问题，基于决策树和SVM的算法都有比较好的表现。</p><h2 id="4）测试评估模型"><a href="#4）测试评估模型" class="headerlink" title="4）测试评估模型"></a>4）测试评估模型</h2><p>测试评估模型的目的在于，解决模型的欠拟合（under-fitting）和过拟合（over-fitting）问题，通过即时的反馈不断调整模型、优化模型，使得模型更加稳健。<br>实际上，测试评估模型应该在你建模之前就考虑，例如是否需要设置纯粹的外部数据验证集，若没有这样的数据，你怎样划分数据进行建模预测？<br>在实际训练中，模型通常对训练数据好，但是对训练数据之外的数据拟合程度差。用于评价模型的泛化能力（即模型普适性）。交叉验证的基本思想是把在某种意义下将原始数据进行分组,一部分做为训练集(train set),另一部分做为验证集(validation set or test set),首先用训练集对模型进行训练,再利用验证集来测试模型的泛化误差。另外，现实中数据总是有限的，为了对数据形成重用，比较常用的是k-fold交叉验证法。测试评估模型的时候，常常结合AUC曲线判断模型好坏。</p><h1 id="sklearn-算法小试"><a href="#sklearn-算法小试" class="headerlink" title="sklearn 算法小试"></a>sklearn 算法小试</h1><h2 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h2><p>sklearn是python中一个强大的机器学习模块,拥有众多的机器学习算法和功能。这里，通过sklearn的datasets构建一个数据集，并用4种常用算法：逻辑回归（LogisticRegression）、支持向量机（SVM）、决策树（DecisionTree）和集成算法（VotingClassifier）对训练集建模，然后对测试集预测，最终通过得分看一下4种算法的差异。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1）构建本次使用的数据集<br>2）将数据拆分成训练集和测试集<br>3）用4种算法分别建模、预测</p><h2 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h2><p>python版本：python3<br>1）如果不想被python各种安装包困扰，推荐Jupyter在线python，<a href="https://jupyter.org/try/" target="_blank" rel="noopener">Jupyter官网</a>，点击”Try Jupyter with Python”，点击“+”号即可。安装包的时候直接pip install packages_name,例如pip install sklearn,点击“Run”，提示“Successfully installed sklearn-0.0”即安装完成。<br><img src="/img/4.png" alt="a3e70c182d26dd77208c02cab6571af5.png"><br>2）Pycharm，专业、高效、强大的python开发端。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets <span class="comment">#built-in datasets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#make_moons,generated datasets</span></span><br><span class="line">X,y = datasets.make_moons(n_samples=<span class="number">500</span>,noise=<span class="number">0.3</span>,random_state=<span class="number">42</span>)</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>],X[y==<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>],X[y==<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()  <span class="comment">#plot for datasets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#split datasets for train and test part</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.logistic regression model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">log_clf=LogisticRegression() <span class="comment">#create LR classifer</span></span><br><span class="line">log_clf.fit(X_train,y_train) <span class="comment">#train and fit the model</span></span><br><span class="line">log_score=log_clf.score(X_test,y_test) <span class="comment">#test the model</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.svm model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svm_clf=SVC()</span><br><span class="line">svm_clf.fit(X_train,y_train)</span><br><span class="line">svm_score=svm_clf.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.decision tree model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">dt_clf=DecisionTreeClassifier()</span><br><span class="line">dt_clf.fit(X_train,y_train)</span><br><span class="line">dt_score=dt_clf.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.ensemble method</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier</span><br><span class="line">voting_clf=VotingClassifier(estimators=</span><br><span class="line">                            [(<span class="string">'log_clf'</span>,LogisticRegression()),</span><br><span class="line">                             (<span class="string">'svm_clf'</span>,SVC()),</span><br><span class="line">                             (<span class="string">'dt_clf'</span>,DecisionTreeClassifier())</span><br><span class="line">                             ],voting=<span class="string">"hard"</span>)</span><br><span class="line">voting_clf.fit(X_train,y_train)</span><br><span class="line">voting_score=voting_clf.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"log score:%s"</span>%log_score)</span><br><span class="line">print(<span class="string">"svm score:%s"</span>%svm_score)</span><br><span class="line">print(<span class="string">"dt score:%s"</span>%dt_score)</span><br><span class="line">print(<span class="string">"voting score:%s"</span>%voting_score)</span><br></pre></td></tr></table></figure><p>构建数据集：<br><img src="/img/5.png" alt="c6e3145820fe446499bfe5166f85b29e.png"><br>4种算法预测结果：<br><img src="/img/6.png" alt="a59578cf44dee88a46ef0bcceabf1b2b.png"><br>可以看到，单一算法SVM比较好，集成算法较单一的算法还是有一定的提高。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/28641663?utm_source=wechat_search&amp;utm_medium=organic" target="_blank" rel="noopener">机器学习中，有哪些特征选择的工程方法？</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODAzMTkyMg==&amp;mid=2247485387&amp;idx=1&amp;sn=d22618f98adae3c9038184b9c4991ea2&amp;chksm=c0698f96f71e06807bbb3c667d50aa87899aa8d7b48bab51be33206390a03cb2e28d3ddb27b4&amp;mpshare=1&amp;scene=24&amp;srcid=0327GWk8nsWdgLT2kYwpeazY#rd" target="_blank" rel="noopener">FeatureSlector:一个可以进行机器学习特征选择的python工具</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjE3OTA1MA==&amp;mid=2247484860&amp;idx=1&amp;sn=7ea3597474f5ceaf443f10d63a8217ee&amp;chksm=ea4e5439dd39dd2f2f0cd95eca909e2ab255fc5dc6e033e9b2d265bf2124751f32e96279188d&amp;scene=7#rd" target="_blank" rel="noopener">机器学习中的交叉验证</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;机器学习数据分析极简思路&quot;&gt;&lt;a href=&quot;#机器学习数据分析极简思路&quot; class=&quot;headerlink&quot; title=&quot;机器学习数据分析极简思路&quot;&gt;&lt;/a&gt;机器学习数据分析极简思路&lt;/h1&gt;&lt;p&gt;机器学习拥有庞大的知识体系，这里对
      
    
    </summary>
    
    
      <category term="machine learing" scheme="http://yoursite.com/tags/machine-learing/"/>
    
  </entry>
  
  <entry>
    <title>Thinking</title>
    <link href="http://yoursite.com/2019/03/22/Thinking/"/>
    <id>http://yoursite.com/2019/03/22/Thinking/</id>
    <published>2019-03-22T02:29:01.000Z</published>
    <updated>2019-03-22T02:38:02.880Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/n1_itc_cn/8104bbb3f6ac26ea840bb95060464cea.GIF" alt="image"><br>Do not just learn day by day, you must think. If no thinking, all is in vain.</p><p>Most people, including me, learn English by reciting words repeatly, which proves inefficient. Don’t be a idiot, to think why!</p><p>Learning should be radial, not layout. Firstly, you must construct a master line, then you need consolidate it continually. Note that, unless you need it, you will not feel it. Everything which you want do better, you must pay enough attention to it. Keep your heart here. To think over it ever and again.</p><p>Learning is a process, not a node. Only if by thinking, you can know it more and more.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/n1_itc_cn/8104bbb3f6ac26ea840bb95060464cea.GIF&quot; alt=&quot;image&quot;&gt;&lt;br&gt;Do not 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TaxonKit usage</title>
    <link href="http://yoursite.com/2019/03/18/TaxonKit-usage/"/>
    <id>http://yoursite.com/2019/03/18/TaxonKit-usage/</id>
    <published>2019-03-18T13:06:16.000Z</published>
    <updated>2019-03-23T16:27:29.152Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>   在做宏基因组分析时，通过基因注释得到一个包含7000多种微生物的拉丁名称list，现在想统计这些微生物分属哪些分类水平（界门纲目科属种）。</p><pre><code>[NeptuneYT$] head scientific_name.txt</code></pre><p>Abiotrophia defectiva<br>Abiotrophia sp.<br>Absiella dolichum<br>Acaryochloris marina<br>Acetanaerobacterium sp.<br>Acetivibrio cellulolyticus<br>Acetoanaerobium noterae<br>Acetoanaerobium sticklandii<br>Acetobacter aceti<br>Acetobacter ghanensis</p><p> 打开NCBI Taxonomy网页，<br> <a href="https://www.ncbi.nlm.nih.gov/taxonomy/" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/taxonomy/</a><br> 输入一个拉丁名，Acetobacter aceti，搜索之后默认获得完整的lineage信息，但我们这里只需要7个层次的，因此再点击一次Lineage获得缩略的谱系信息，如下：<br>   <img src="en-resource://database/4366:1" alt="e6cbb27a22c5c7a2b3a2ba23edb1a805.png"><br>得到的Lineage字段后以分号隔开的就是对应于7个分类层次的结果，后续以分号切割之后统计不同列的结果即可。<br>很自然的我们想到爬虫，其搜索接口为<a href="https://www.ncbi.nlm.nih.gov/taxonomy/?term=拉丁名（空格以+号连接），如https://www.ncbi.nlm.nih.gov/taxonomy/?term=Acetobacter+aceti，然后对结果页面进行后续解析。但是考虑到7000之多的查询量，网速必然有极大影响，因此果断放弃。其实，从网上查询的原理也是基于Taxonomy后台的数据库，而这个文件在ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz，可以从解压之后的names.dmp和nodes.dmp文件写代码解析，但是其内容过于妖孽，因此先看看网上是否有造好的轮子。" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/taxonomy/?term=拉丁名（空格以+号连接），如https://www.ncbi.nlm.nih.gov/taxonomy/?term=Acetobacter+aceti，然后对结果页面进行后续解析。但是考虑到7000之多的查询量，网速必然有极大影响，因此果断放弃。其实，从网上查询的原理也是基于Taxonomy后台的数据库，而这个文件在ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz，可以从解压之后的names.dmp和nodes.dmp文件写代码解析，但是其内容过于妖孽，因此先看看网上是否有造好的轮子。</a><br>   <img src="en-resource://database/4368:1" alt="a779d01a5ad056030870717c9834834c.png"><br>果然有三个工具可以实现，ETE toolkit, taxadb和 TaxonKit，这里选择最近发表的TaxonKit，优势在于其直接基于names.dmp和nodes.dmp文件的解析，本地搜索速度块，尤其是大批量的查找和格式转换，另外使用也极简单。<br>   <img src="en-resource://database/4370:1" alt="b3fdb657d91fc76b4cce0794a9133157.png"><br>   相比于另外两种工具，TaxonKit在处理大批量数据时更快，占用内存也可接受<br>   （ <a href="http://dx.doi.org/10.1101/513523）" target="_blank" rel="noopener">http://dx.doi.org/10.1101/513523）</a></p><h1 id="taxonkit-概述"><a href="#taxonkit-概述" class="headerlink" title="taxonkit 概述"></a>taxonkit 概述</h1><p>TaxonKit是处理NCBI Taxonomy数据库中结构性数据的良心工具，19年1月发表在bioRxiv上，作者Wei Shen, Jie Xiong，隶属于Department of ClinicalLaboratory, General Hospital of Western Theater Command，特地查了一下，原来是位于成都的中国人民解放军西部战区总医院（好牛的感觉），看来生信真是无处不在。<br><img src="en-resource://database/4362:1" alt="50ba3f6f06f1bd5a6af882128668bbdb.png"><br><img src="en-resource://database/4364:1" alt="e8237772973853ffcfd38f570c47f371.png"><br>它是Go语言编写的，可以在Windows，Linux和Mac OS X运行，直接使用NCBI Taxonomy的数据（需手动下载）而无需构建本地数据库。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="taxonkit安装"><a href="#taxonkit安装" class="headerlink" title="taxonkit安装"></a>taxonkit安装</h2><p>选择对应系统的版本安装，推荐conda安装。详见<a href="https://github.com/shenwei356/taxonkit" target="_blank" rel="noopener">https://github.com/shenwei356/taxonkit</a><br>conda安装如下：</p><pre><code>conda install -c bioconda taxonkit</code></pre><h2 id="下载依赖数据"><a href="#下载依赖数据" class="headerlink" title="下载依赖数据"></a>下载依赖数据</h2><p>下载NCBI taxonomy数据库的taxdump.tar.gz文件，解压后将names.dmp和 nodes.dmp拷贝到家目录下的.taxonkit目录下。</p><pre><code>wget -c ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gztar -zxvf taxdump.tar.gzmkdir -p $HOME/.taxonkitcp names.dmp nodes.dmp $HOME/.taxonkit</code></pre><p>查看：</p><pre><code>[NeptuneYT]$ ll -h  ~/.taxonkit/</code></pre><p>total 155494<br>-rw-r–r–    1 yutao    UsersGrp  169.3M Mar 18 16:07 names.dmp<br>-rw-r–r–    1 yutao    UsersGrp  134.4M Mar 18 16:07 nodes.dmp<br>配置完成，开始使用。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code>[NeptuneYT$] taxonkit --help</code></pre><p>   Usage:<br>  taxonkit [command]</p><p>Available Commands:<br>  genautocomplete generate shell autocompletion script<br>  help            Help about any command<br>  lineage         query lineage of given taxids<br>  list            list taxon tree of given taxids<br>  name2taxid      query taxid by taxon scientific name<br>  reformat        reformat lineage<br>  version         print version information and check for update</p><p>Flags:<br>      –data-dir string   directory containing nodes.dmp and names.dmp (default “/home/yutao/.taxonkit”)<br>  -h, –help              help for taxonkit<br>      –line-buffered     use line buffering on output, i.e., immediately writing to stdin/file for every<br>  -o, –out-file string   out file (“-“ for stdout, suffix .gz for gzipped out) (default “-“)<br>  -j, –threads int       number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)<br>      –verbose           print verbose information</p><p>Use “taxonkit [command] –help” for more information about a command.<br>taxonkit按照功能分成不同的子命令，其中最主要的功能包括4块：<br>1）列出给定taxonomy id(taxid)的子分类树：list<br>2）从taxid获取完整谱系：lineage<br>3）重新构造谱系的格式：reformat<br>4）通过物种拉丁名查询taxid：name2taxid</p><h2 id="1）-列出给定taxonomy-id-taxid-的子分类树"><a href="#1）-列出给定taxonomy-id-taxid-的子分类树" class="headerlink" title="1） 列出给定taxonomy id(taxid)的子分类树"></a>1） 列出给定taxonomy id(taxid)的子分类树</h2><pre><code>[NeptuneYT$] taxonkit list --help   #查看list子命令使用方法</code></pre><p>list taxon tree of given taxids</p><p>Usage:<br>  taxonkit list [flags]</p><p>Flags:<br>  -h, –help            help for list<br>      –ids string      taxid(s), multiple values should be separated by comma<br>      –indent string   indent (default “  “)<br>      –json            output in JSON format. you can save the result in file with suffix “.json” and open with modern text editor<br>      –show-name       output scientific name<br>      –show-rank       output rank</p><p>Global Flags:<br>      –data-dir string   directory containing nodes.dmp and names.dmp (default “/home/yutao/.taxonkit”)<br>      –line-buffered     use line buffering on output, i.e., immediately writing to stdin/file for every line of output<br>  -o, –out-file string   out file (“-“ for stdout, suffix .gz for gzipped out) (default “-“)<br>  -j, –threads int       number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)<br>      –verbose           print verbose information<br>实例：</p><pre><code>[NeptuneYT$] taxonkit list --ids 9606,10090 --show-name  --show-rank -j 2#--ids 给定的taxid，多个以英文逗号分割#--show-name    输出科学命名#--show-rank    输出分类等级#-j 线程数，默认是2</code></pre><p>9606 [species] Homo sapiens<br>  63221 [subspecies] Homo sapiens neanderthalensis<br>  741158 [subspecies] Homo sapiens subsp. ‘Denisova’</p><p>10090 [species] Mus musculus<br>  10091 [subspecies] Mus musculus castaneus<br>  10092 [subspecies] Mus musculus domesticus<br>  35531 [subspecies] Mus musculus bactrianus<br>  39442 [subspecies] Mus musculus musculus<br>  46456 [subspecies] Mus musculus wagneri<br>  57486 [subspecies] Mus musculus molossinus<br>  80274 [subspecies] Mus musculus gentilulus<br>  116058 [subspecies] Mus musculus brevirostris<br>  179238 [subspecies] Mus musculus homourus<br>  477815 [subspecies] Mus musculus musculus x M. m. domesticus<br>  477816 [subspecies] Mus musculus musculus x M. m. castaneus<br>  947985 [subspecies] Mus musculus albula<br>  1266728 [subspecies] Mus musculus domesticus x M. m. molossinus<br>  1385377 [subspecies] Mus musculus gansuensis<br>  1643390 [subspecies] Mus musculus helgolandicus<br>  1879032 [subspecies] Mus musculus isatissus</p><h1 id="2）从taxid获取完整谱系"><a href="#2）从taxid获取完整谱系" class="headerlink" title="2）从taxid获取完整谱系"></a>2）从taxid获取完整谱系</h1><pre><code>[NeptuneYT$] taxonkit lineage --help</code></pre><p>query lineage of given taxids</p><p>Usage:<br>  taxonkit lineage [flags]</p><p>Flags:<br>  -d, –delimiter string      field delimiter in lineage (default “;”)<br>  -h, –help                  help for lineage<br>  -t, –show-lineage-taxids   show lineage consisting of taxids<br>  -r, –show-rank             show rank of taxids<br>  -i, –taxid-field int       field index of taxid. data should be tab-separated (default 1)</p><p>Global Flags:<br>      –data-dir string   directory containing nodes.dmp and names.dmp (default “/home/yutao/.taxonkit”)<br>      –line-buffered     use line buffering on output, i.e., immediately writing to stdin/file for every line of output<br>  -o, –out-file string   out file (“-“ for stdout, suffix .gz for gzipped out) (default “-“)<br>  -j, –threads int       number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)<br>      –verbose           print verbose information</p><pre><code>[NeptuneYT$] echo 9606|taxonkit lineage  -d &quot;-&quot; -t -r#-d 输出谱系树分割符，默认分号#-t 显示包含taxid的谱系树#-r 显示给定taxid的分类等级</code></pre><p>9606    cellular organisms-Eukaryota-Opisthokonta-Metazoa-Eumetazoa-Bilateria-Deuterostomia-Chordata-Craniata-Vertebrata-Gnathostomata-Teleostomi-Euteleostomi-Sarcopterygii-Dipnotetrapodomorpha-Tetrapoda-Amniota-Mammalia-Theria-Eutheria-Boreoeutheria-Euarchontoglires-Primates-Haplorrhini-Simiiformes-Catarrhini-Hominoidea-Hominidae-Homininae-Homo-Homo sapiens      131567-2759-33154-33208-6072-33213-33511-7711-89593-7742-7776-117570-117571-8287-1338369-32523-32524-40674-32525-9347-1437010-314146-9443-376913-314293-9526-314295-9604-207598-9605-9606   species</p><h1 id="3）重新构造谱系的格式"><a href="#3）重新构造谱系的格式" class="headerlink" title="3）重新构造谱系的格式"></a>3）重新构造谱系的格式</h1><p>上一步通过taxid提取的谱系信息复杂，往往需要根据我们的需求重新格式化</p><pre><code>[NeptuneYT$] taxonkit reformat --help</code></pre><p>reformat lineage</p><p>Output format can be formated by flag –format, available placeholders:<br>    {k}: superkingdom<br>    {p}: phylum<br>    {c}: class<br>    {o}: order<br>    {f}: family<br>    {g}: genus<br>    {s}: species<br>    {S}: subspecies</p><p>Output format can contains some escape charactors like “\t”.</p><p>This command appends reformated lineage to the input line.<br>The corresponding taxids of reformated lineage can be provided as another<br>column by flag “-t/–show-lineage-taxids”.</p><p>Usage:<br>  taxonkit reformat [flags]</p><p>Flags:<br>  -d, –delimiter string               field delimiter in input lineage (default “;”)<br>  -F, –fill-miss-rank                 fill missing rank with original lineage information (experimental)<br>  -f, –format string                  output format, placeholders of rank are needed (default “{k};{p};{c};{o};{f};{g};{s}”)<br>  -h, –help                           help for reformat<br>  -i, –lineage-field int              field index of lineage. data should be tab-separated (default 2)<br>  -r, –miss-rank-repl string          replacement string for missing rank, if given “”, “unclassified xxx xxx” will used, where “unclassified “ is settable by flag -p/–miss-rank-repl-prefix<br>  -p, –miss-rank-repl-prefix string   prefix for estimated taxon level (default “unclassified “)<br>  -R, –miss-taxid-repl string         replacement string for missing taxid<br>  -t, –show-lineage-taxids            show corresponding taxids of reformated lineage</p><p>Global Flags:<br>      –data-dir string   directory containing nodes.dmp and names.dmp (default “/home/yutao/.taxonkit”)<br>      –line-buffered     use line buffering on output, i.e., immediately writing to stdin/file for every line of output<br>  -o, –out-file string   out file (“-“ for stdout, suffix .gz for gzipped out) (default “-“)<br>  -j, –threads int       number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)<br>      –verbose           print verbose information<br>实例：</p><pre><code>[NeptuneYT$] echo 9606|taxonkit lineage |taxonkit reformat</code></pre><p>9606    cellular organisms;Eukaryota;Opisthokonta;Metazoa;Eumetazoa;Bilateria;Deuterostomia;Chordata;Craniata;Vertebrata;Gnathostomata;Teleostomi;Euteleostomi;Sarcopterygii;Dipnotetrapodomorpha;Tetrapoda;Amniota;Mammalia;Theria;Eutheria;Boreoeutheria;Euarchontoglires;Primates;Haplorrhini;Simiiformes;Catarrhini;Hominoidea;Hominidae;Homininae;Homo;Homo sapiens      Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens<br>输出结果的第三列就是重新格式化的结果，默认是(“{k};{p};{c};{o};{f};{g};{s}”)7个水平。<br>查询给定taxid9606的谱系，并按照门：科；属的格式输出</p><pre><code>[NeptuneYT$] echo 9606|taxonkit lineage |taxonkit reformat -f &quot;{p}:{f};{s}&quot; |cut -f3#{}内是分类等级，大括号之间是输出的连接符</code></pre><p>Chordata:Hominidae;Homo sapiens</p><h1 id="4）通过物种拉丁名查询taxid：name2taxid"><a href="#4）通过物种拉丁名查询taxid：name2taxid" class="headerlink" title="4）通过物种拉丁名查询taxid：name2taxid"></a>4）通过物种拉丁名查询taxid：name2taxid</h1><pre><code>[NeptuneYT$] taxonkit name2taxid --help</code></pre><p>query taxid by taxon scientific name</p><p>Usage:<br>  taxonkit name2taxid [flags]</p><p>Flags:<br>  -h, –help             help for name2taxid<br>  -i, –name-field int   field index of name. data should be tab-separated (default 1)<br>      –show-rank        show rank</p><p>Global Flags:<br>      –data-dir string   directory containing nodes.dmp and names.dmp (default “/home/yutao/.taxonkit”)<br>      –line-buffered     use line buffering on output, i.e., immediately writing to stdin/file for every line of output<br>  -o, –out-file string   out file (“-“ for stdout, suffix .gz for gzipped out) (default “-“)<br>  -j, –threads int       number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)<br>      –verbose           print verbose information</p><p>实例：<br>依据人的拉丁名查询taxid</p><pre><code>[NeptuneYT$] echo &quot;Homo sapiens&quot; |taxonkit name2taxid</code></pre><p>Homo sapiens    9606<br>批量查询</p><pre><code>[NeptuneYT$] head scientific_name.txt |taxonkit name2taxid --show-rank</code></pre><p>Abiotrophia defectiva   46125   species<br>Abiotrophia sp. 76631   species<br>Absiella dolichum       31971   species<br>Acaryochloris marina    155978  species<br>Acetanaerobacterium sp.<br>Acetivibrio cellulolyticus      35830   species<br>Acetoanaerobium noterae 745369  species<br>Acetoanaerobium sticklandii     1511    species<br>Acetobacter aceti       435     species<br>Acetobacter ghanensis   431306  species</p><p>基于上述用法，回到之前的问题就好解决了<br>1.将scientific name先转化成taxid，便于查找lineage</p><pre><code>time taxonkit name2taxid  scientific_name.txt &gt;scientific_name_taxid.txt &amp;awk -F&quot;\t&quot; &apos;$2!=&quot;&quot;{print $2}&apos;  scientific_name.txt &gt;find_taxid.txt  #去掉未查到的，即空值</code></pre><p>real    0m6.279s<br>可以看到，查询速度相当之快<br>2.查找lineage</p><pre><code>[NeptuneYT$] time taxonkit lineage find_taxid.txt &gt;lineage.txt&amp;</code></pre><p>real    0m7.860s<br>3.重新格式化lineage</p><pre><code>[NeptuneYT$] time taxonkit reformat lineage.txt|cut -f3 &gt;newformat.txt&amp;</code></pre><p>real    0m11.465s<br>结果：<br><img src="en-resource://database/4372:0" alt="a5b75e8f601a793caab21771ee9d2630.png"><br>现在就按照界门纲目科属种的层次变成整齐划一的格式了，通过简单处理即可统计不同层次的物种数量和分布，首先构建一个用于循环处理的分类标签</p><pre><code>[NeptuneYT$] cat tag.txt</code></pre><p>1       k<br>2       p<br>3       c<br>4       o<br>5       f<br>6       g<br>7       s<br>详细的物种分类层次数量统计：</p><pre><code>cat tag.txt|while read num lev;do  awk -v v=$num -F&quot;;&quot; &apos;{print $v}&apos; newformat.txt|sort |uniq -c|sort -nr |awk -v v=$lev &apos;{print v&quot;\t&quot;$0}&apos; |awk &apos;$3!=&quot;&quot;&apos;;done &gt;detail_taxonomy_range.txt[NeptuneYT$] head detail_taxonomy_range.txt</code></pre><p>k          6722 Bacteria<br>k             4 Eukaryota<br>p          2682 Proteobacteria<br>p          1390 Firmicutes<br>p          1099 Actinobacteria<br>p           729 Bacteroidetes<br>p           136 Tenericutes<br>p            86 Spirochaetes<br>p            85 Cyanobacteria<br>p            40 Deinococcus-Thermus</p><p>7个类别数量统计：</p><pre><code>[NeptuneYT$] cat tag.txt|while read index level;do num=$(awk -v v=$index -F&quot;;&quot; &apos;{print $v}&apos; newformat.txt|sort |uniq |wc -l);printf  &quot;${level}\t${num}\n&quot;;done |tee taxonomy_stat.txt</code></pre><p>k       2<br>p       118<br>c       82<br>o       181<br>f       401<br>g       1824<br>s       6519</p><p>简单画个图瞅瞅：</p><pre><code>data&lt;-read.table(&apos;taxonomy_stat.txt&apos;)library(&apos;ggplot2&apos;)ggplot(a,aes(reorder(V1,-V2),V2,fill=V1))+geom_bar(stat=&apos;identity&apos;)+xlab(&apos;Taxonomy level&apos;)+ylab(&apos;Numbers&apos;)+geom_text(aes(label=V2),position=position_dodge(.9),vjust=-1.5)+theme(text=element_text(size=16,family=&apos;Times New Roman&apos;,face=&apos;bold&apos;))+labs(fill=&apos;level&apos;)</code></pre><p> <img src="en-resource://database/4374:0" alt="7a4bd388c517c803b8abe18473d705c7.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/shenwei356/taxonkit" target="_blank" rel="noopener">https://github.com/shenwei356/taxonkit</a><br><a href="https://bioinf.shenwei.me/taxonkit/usage/" target="_blank" rel="noopener">https://bioinf.shenwei.me/taxonkit/usage/</a><br><a href="http://dx.doi.org/10.1101/513523" target="_blank" rel="noopener">http://dx.doi.org/10.1101/513523</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h1&gt;&lt;p&gt;   在做宏基因组分析时，通过基因注释得到一个包含7000多种微生物的拉丁名称list，现
      
    
    </summary>
    
      <category term="bioinformatics" scheme="http://yoursite.com/categories/bioinformatics/"/>
    
    
      <category term="taxonomy classfication" scheme="http://yoursite.com/tags/taxonomy-classfication/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/12/test/"/>
    <id>http://yoursite.com/2019/03/12/test/</id>
    <published>2019-03-12T11:58:57.112Z</published>
    <updated>2019-03-12T11:58:57.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk版本"><a href="#awk版本" class="headerlink" title="awk版本"></a>awk版本</h2><pre><code>$ awk --version</code></pre><p>GNU Awk 4.0.2<br>Copyright (C) 1989, 1991-2012 Free Software Foundation.</p><pre><code>$ cat test.txt</code></pre><p>1e2<br>1e-2<br>1e-10<br>1e-20<br>2e-10</p><pre><code>$ awk &apos;$1&lt;1e-10&apos; test.txt</code></pre><p>1e-20</p><pre><code>$ awk &apos;$1&gt;1e-4&apos; test.txt</code></pre><p>1e2<br>1e-2</p><pre><code>$ awk &apos;$1&gt;0.01&apos; test.txt</code></pre><p>1e2</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><pre><code>$ sort -g  test.txt</code></pre><p>1e-20<br>1e-10<br>2e-10<br>1e-2<br>1e2</p><pre><code>$ sort -gr  test.txt</code></pre><p>1e2<br>1e-2<br>2e-10<br>1e-10<br>1e-20</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;awk版本&quot;&gt;&lt;a href=&quot;#awk版本&quot; class=&quot;headerlink&quot; title=&quot;awk版本&quot;&gt;&lt;/a&gt;awk版本&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$ awk --version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;GNU Awk 4.0.2&lt;br&gt;C
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/03/12/hello-world/"/>
    <id>http://yoursite.com/2019/03/12/hello-world/</id>
    <published>2019-03-12T07:24:37.208Z</published>
    <updated>2019-03-12T07:24:37.209Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
