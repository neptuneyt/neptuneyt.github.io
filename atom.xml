<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NeptuneYT&#39;s Blog</title>
  
  <subtitle>I think, therefore I am.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-14T01:22:58.288Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>neptuneyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>We Brother</title>
    <link href="http://yoursite.com/2019/04/14/We-Brother/"/>
    <id>http://yoursite.com/2019/04/14/We-Brother/</id>
    <published>2019-04-14T01:16:33.000Z</published>
    <updated>2019-04-14T01:22:58.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/img/cw.jpg" alt="cw"><br><img src="/img/we.jpg" alt="cw"><br><img src="/img/dy.jpg" alt="cw"><br><img src="/img/fzw.jpg" alt="cw"><br><img src="/img/hengyu.jpg" alt="cw"><br><img src="/img/hyy.jpg" alt="cw"><br><img src="/img/wjw.jpg" alt="cw"><br><img src="/img/wwb.jpg" alt="cw"><br><img src="/img/y.jpg" alt="cw"><br><img src="/img/sj.jpg" alt="cw"><br><img src="/img/lj.jpg" alt="cw"><br><img src="/img/cp.jpg" alt="cw"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Machine learning KFC</title>
    <link href="http://yoursite.com/2019/03/27/Machine-learning-KFC/"/>
    <id>http://yoursite.com/2019/03/27/Machine-learning-KFC/</id>
    <published>2019-03-27T09:27:56.000Z</published>
    <updated>2019-04-01T08:05:13.036Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-icHbHfDD" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28287132" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h1 id="机器学习数据分析极简思路"><a href="#机器学习数据分析极简思路" class="headerlink" title="机器学习数据分析极简思路"></a>机器学习数据分析极简思路</h1><p><strong>机器学习拥有庞大的知识体系，这里对机器学习的数据分析的整个思路和流程作最最简单的归纳。机器学习的步骤大致包括：<br>1）理解和清理数据<br>2）特征选择<br>3）算法建模<br>4）测试评估模型</strong><br><a id="more"></a></p><h2 id="1）理解和清理数据"><a href="#1）理解和清理数据" class="headerlink" title="1）理解和清理数据"></a>1）理解和清理数据</h2><ul><li>理解数据<br>数据是机器学习大餐的原始食材，对数据分析起着至关重要的作用，理解原始数据的含义将有助于进一步分析。例如，甲基化图谱与年龄有着显著的相关性，而与性别关系不大，因此在数据分析中，对这两个特征（feature）需要区别对待。更好的理解方式是直接可视化某些数据，例如对于经典的鸢尾花数据集，可以通过python seaborn绘图包可视化各个特征（feature）之间的关系；对于大数据，则可以进行降维分析（PCOA、tSNE），理解数据组成主成分贡献度。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pip install seaborn</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">%matplotlib inline</span><br><span class="line">data=pd.read_csv(<span class="string">'iris.csv'</span>)    <span class="comment">#pandas 读入数据</span></span><br><span class="line">data.head(<span class="number">3</span>)    <span class="comment">#查看数据</span></span><br><span class="line">data.describe() <span class="comment">#数据基本统计</span></span><br><span class="line">sb.pairplot(data.dropna(),hue=<span class="string">'Species'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>鸢尾花数据组成<br><img src="/img/1.png" alt="32bc1a777af3001e5fc1dea42b93c0d1.png"><br>鸢尾花数据所有feature基本数理统计<br><img src="/img/2.png" alt="2b240766f89ac4edf021b4341265784a.png"><br>鸢尾花数据不同feature相互关系<br><img src="/img/3.png" alt="c6662ebd0cefd5735191807c454d879a.png"></p><ul><li>剔除异常值<br>清理数据的目的在于去除原始数据中的异常值和想办法处理缺失值，我们拿到手上的数据不可能尽善尽美，总有一些妖孽作祟，对于异常值我们应当剔除。举个栗子，假设在鸢尾花数据集中，有一个样本显示鸢尾花花瓣长度10m，其他诸如花瓣宽度、花萼长宽值都正常，可以脑补一下这是一朵什么样的花，那么这个样本显然应该剔除。</li><li>处理缺失值<br>缺失值在数据分析中很常见，总有一些样本观测值会因为这那的问题缺失，处理缺失值如果样本数量很大，而包含缺失值的样本又少，这个时候果断去掉这些样本，眼不见为净；如果因为样本有限或者缺失值太多，就要想办法补全缺失值（imputation）,常常利用逻辑回归建立模型，找出这些数据变化的规律，从而预测缺失值。如何合理推断和填回这些缺失值是一门大学问，哪种方法好，我也不敢妄言。</li></ul><h2 id="2）特征选择"><a href="#2）特征选择" class="headerlink" title="2）特征选择"></a>2）特征选择</h2><p>工业界广泛流传的一句话是：<strong>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已</strong>。由此可见，特征选择是机器学习的关键的关键。特征选择目的在于提取跟目标最为有效的信息，降低数据维度和计算成本，同时防止过拟合（overfitting，训练集特征用的太多太细，以致于在测试集中不适）。要知道，并不是特征越多，结果越好，没有严格意义上的特征累加效应，有时候好的几个特征胜于大量零碎的特征取得的效果。<br>在许多大数据挖掘竞赛中（国内的阿里天池和国外的kaggle平台），最复杂的过程莫过于特征工程建立阶段，大概占据了整个竞赛过程的70%的时间和精力，最终建立的模型的好坏大多也取决于特征工程建立的好坏。遗憾的是，特征工程不像模型建立的过程有着固定的套路，特征工程的建立凭借的更多的是经验，因此没有统一的方法。这里抛砖引玉介绍一些常见的办法，更为详细的内容请参考文后链接。<br><strong>a)特征过滤法</strong><br>比较简单，它按照特征的发散性或者相关性指标对各个特征进行评分，设定评分阈值或者待选择阈值的个数，选择合适特征。例如，我们可以简单的计算出每个feature的方差，方差越大说明这个feature在样本中变异大，即有区分性；而越小的（极端时方差为0），即表示在所有样本中一样，特征选择时则可不考虑这些特征。我们可以选择方差最大的前n个feature用于建模，这就是最为简单的方差筛选法。<br><strong>b)包装法</strong><br>根据目标函数，通常是预测效果评分，每次选择部分特征，或者排除部分特征。<br><strong>c)嵌入法</strong><br>则稍微复杂一点，它先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据权值系数从大到小来选择特征。类似于过滤法，但是它是通过机器学习训练来确定特征的优劣，而不是直接从特征的一些统计学指标来确定特征的优劣。<br>踩雷说：特征选择之后，需要从原始数据矩阵提取相应的特征重构矩阵，那么训练集和测试集的特征经过你各种变换之后，应当保持一一对应，类别和顺序在矩阵中都应该一致。<br>目前，已经有一些套路化的特征选择工具，例如python的FeatureSlector包，见链接。</p><h2 id="3）算法建模"><a href="#3）算法建模" class="headerlink" title="3）算法建模"></a>3）算法建模</h2><p>针对具体的问题，是分类问题？回归问题？还是其他？选择合适的模型，或者使用集成的算法模型。常见的算法模型包括：<br>对于回归问题：<br>a)线性回归（回归，LinearRegression）<br>b)岭回归（回归，Ridge）Ridge是线性回归加L2正则平方，以防止过拟合<br>c)拉索回归（Lasso），加入惩罚函数L1正则绝对值，防止过拟合<br>d)弹性网络回归（回归），同时使用L1和L2正则。<br>e)K近邻（回归和分类，KNeighborsRegressor）<br>f)决策树（回归和分类，DecisionTreeRegressor）<br>g)支持向量机（回归和分类，SVR）</p><p>对于分类问题：<br>a)支持向量机（回归和分类，SVC）<br>b决策树（回归与分类,DecisionTreeClassifier）<br>c)逻辑回归（分类,LogisticRegression)<br>d)LDA线性判别分析（分类,LinearDiscriminantAnalysis)<br>e)K近邻（分类,KNeighborsClassifier)<br>值得一提的是无论是分类还是回归问题，基于决策树和SVM的算法都有比较好的表现。</p><h2 id="4）测试评估模型"><a href="#4）测试评估模型" class="headerlink" title="4）测试评估模型"></a>4）测试评估模型</h2><p>测试评估模型的目的在于，解决模型的欠拟合（under-fitting）和过拟合（over-fitting）问题，通过即时的反馈不断调整模型、优化模型，使得模型更加稳健。<br>实际上，测试评估模型应该在你建模之前就考虑，例如是否需要设置纯粹的外部数据验证集，若没有这样的数据，你怎样划分数据进行建模预测？<br>在实际训练中，模型通常对训练数据好，但是对训练数据之外的数据拟合程度差。用于评价模型的泛化能力（即模型普适性）。交叉验证的基本思想是把在某种意义下将原始数据进行分组,一部分做为训练集(train set),另一部分做为验证集(validation set or test set),首先用训练集对模型进行训练,再利用验证集来测试模型的泛化误差。另外，现实中数据总是有限的，为了对数据形成重用，比较常用的是k-fold交叉验证法。测试评估模型的时候，常常结合AUC曲线判断模型好坏。</p><h1 id="sklearn-算法小试"><a href="#sklearn-算法小试" class="headerlink" title="sklearn 算法小试"></a>sklearn 算法小试</h1><h2 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h2><p>sklearn是python中一个强大的机器学习模块,拥有众多的机器学习算法和功能。这里，通过sklearn的datasets构建一个数据集，并用4种常用算法：逻辑回归（LogisticRegression）、支持向量机（SVM）、决策树（DecisionTree）和集成算法（VotingClassifier）对训练集建模，然后对测试集预测，最终通过得分看一下4种算法的差异。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1）构建本次使用的数据集<br>2）将数据拆分成训练集和测试集<br>3）用4种算法分别建模、预测</p><h2 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h2><p>python版本：python3<br>1）如果不想被python各种安装包困扰，推荐Jupyter在线python，<a href="https://jupyter.org/try/" target="_blank" rel="noopener">Jupyter官网</a>，点击”Try Jupyter with Python”，点击“+”号即可。安装包的时候直接pip install packages_name,例如pip install sklearn,点击“Run”，提示“Successfully installed sklearn-0.0”即安装完成。<br><img src="/img/4.png" alt="a3e70c182d26dd77208c02cab6571af5.png"><br>2）Pycharm，专业、高效、强大的python开发端。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets <span class="comment">#built-in datasets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#make_moons,generated datasets</span></span><br><span class="line">X,y = datasets.make_moons(n_samples=<span class="number">500</span>,noise=<span class="number">0.3</span>,random_state=<span class="number">42</span>)</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>],X[y==<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>],X[y==<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()  <span class="comment">#plot for datasets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#split datasets for train and test part</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.logistic regression model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">log_clf=LogisticRegression() <span class="comment">#create LR classifer</span></span><br><span class="line">log_clf.fit(X_train,y_train) <span class="comment">#train and fit the model</span></span><br><span class="line">log_score=log_clf.score(X_test,y_test) <span class="comment">#test the model</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.svm model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svm_clf=SVC()</span><br><span class="line">svm_clf.fit(X_train,y_train)</span><br><span class="line">svm_score=svm_clf.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.decision tree model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">dt_clf=DecisionTreeClassifier()</span><br><span class="line">dt_clf.fit(X_train,y_train)</span><br><span class="line">dt_score=dt_clf.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.ensemble method</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier</span><br><span class="line">voting_clf=VotingClassifier(estimators=</span><br><span class="line">                            [(<span class="string">'log_clf'</span>,LogisticRegression()),</span><br><span class="line">                             (<span class="string">'svm_clf'</span>,SVC()),</span><br><span class="line">                             (<span class="string">'dt_clf'</span>,DecisionTreeClassifier())</span><br><span class="line">                             ],voting=<span class="string">"hard"</span>)</span><br><span class="line">voting_clf.fit(X_train,y_train)</span><br><span class="line">voting_score=voting_clf.score(X_test,y_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"log score:%s"</span>%log_score)</span><br><span class="line">print(<span class="string">"svm score:%s"</span>%svm_score)</span><br><span class="line">print(<span class="string">"dt score:%s"</span>%dt_score)</span><br><span class="line">print(<span class="string">"voting score:%s"</span>%voting_score)</span><br></pre></td></tr></table></figure><p>构建数据集：<br><img src="/img/5.png" alt="c6e3145820fe446499bfe5166f85b29e.png"><br>4种算法预测结果：<br><img src="/img/6.png" alt="a59578cf44dee88a46ef0bcceabf1b2b.png"><br>可以看到，单一算法SVM比较好，集成算法较单一的算法还是有一定的提高。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/28641663?utm_source=wechat_search&amp;utm_medium=organic" target="_blank" rel="noopener">机器学习中，有哪些特征选择的工程方法？</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODAzMTkyMg==&amp;mid=2247485387&amp;idx=1&amp;sn=d22618f98adae3c9038184b9c4991ea2&amp;chksm=c0698f96f71e06807bbb3c667d50aa87899aa8d7b48bab51be33206390a03cb2e28d3ddb27b4&amp;mpshare=1&amp;scene=24&amp;srcid=0327GWk8nsWdgLT2kYwpeazY#rd" target="_blank" rel="noopener">FeatureSlector:一个可以进行机器学习特征选择的python工具</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjE3OTA1MA==&amp;mid=2247484860&amp;idx=1&amp;sn=7ea3597474f5ceaf443f10d63a8217ee&amp;chksm=ea4e5439dd39dd2f2f0cd95eca909e2ab255fc5dc6e033e9b2d265bf2124751f32e96279188d&amp;scene=7#rd" target="_blank" rel="noopener">机器学习中的交叉验证</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-icHbHfDD&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;28287132&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
&lt;h1 id=&quot;机器学习数据分析极简思路&quot;&gt;&lt;a href=&quot;#机器学习数据分析极简思路&quot; class=&quot;headerlink&quot; title=&quot;机器学习数据分析极简思路&quot;&gt;&lt;/a&gt;机器学习数据分析极简思路&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;机器学习拥有庞大的知识体系，这里对机器学习的数据分析的整个思路和流程作最最简单的归纳。机器学习的步骤大致包括：&lt;br&gt;1）理解和清理数据&lt;br&gt;2）特征选择&lt;br&gt;3）算法建模&lt;br&gt;4）测试评估模型&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="machine learing" scheme="http://yoursite.com/tags/machine-learing/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="sklearn" scheme="http://yoursite.com/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>Thinking</title>
    <link href="http://yoursite.com/2019/03/22/Thinking/"/>
    <id>http://yoursite.com/2019/03/22/Thinking/</id>
    <published>2019-03-22T02:29:01.000Z</published>
    <updated>2019-04-01T08:28:07.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>I think,therefore I am!</strong><br><a id="more"></a><br><img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/n1_itc_cn/8104bbb3f6ac26ea840bb95060464cea.GIF" alt="image"><br>Do not just learn day by day, you must think. If no thinking, all is in vain.</p><p>Most people, including me, learn English by reciting words repeatly, which proves inefficient. Don’t be a idiot, to think why!</p><p>Learning should be radial, not layout. Firstly, you must construct a master line, then you need consolidate it continually. Note that, unless you need it, you will not feel it. Everything which you want do better, you must pay enough attention to it. Keep your heart here. To think over it ever and again.</p><p>Learning is a process, not a node. Only if by thinking, you can know it more and more.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;I think,therefore I am!&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TaxonKit usage</title>
    <link href="http://yoursite.com/2019/03/18/TaxonKit-usage/"/>
    <id>http://yoursite.com/2019/03/18/TaxonKit-usage/</id>
    <published>2019-03-18T13:06:16.000Z</published>
    <updated>2019-04-04T00:53:23.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-xJYhtUKW" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28287132" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p><strong>在做宏基因组分析时，通过基因注释得到一个包含10k之多种微生物物种名list(scientific name)，现在想统计这些微生物分属哪些分类水平（界门纲目科属种）。<br>这就是本篇推送想解决的问题，10000多种微生物的拉丁名称示例如下：</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] head scientific_name.txt</span><br></pre></td></tr></table></figure></p><p>Abiotrophia defectiva<br>Abiotrophia sp.<br>Absiella dolichum<br>Acaryochloris marina<br>Acetanaerobacterium sp.<br>Acetivibrio cellulolyticus<br>Acetoanaerobium noterae<br>Acetoanaerobium sticklandii<br>Acetobacter aceti<br>Acetobacter ghanensis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] wc -l all_bacteria_genomic_fna.species</span><br></pre></td></tr></table></figure></p><p>10146 all_bacteria_genomic_fna.species</p><p>打开<a href="https://www.ncbi.nlm.nih.gov/taxonomy/" target="_blank" rel="noopener">NCBI Taxonomy</a>输入一个拉丁名，如Acetobacter aceti，搜索之后默认获得完整的lineage信息，但我们这里只需要7个层次的，因此再点击一次Lineage获得缩略的谱系信息，如下：<br>   <img src="/img/taxonkit_usage1.png" alt="e6cbb27a22c5c7a2b3a2ba23edb1a805.png"><br>得到的Lineage字段后以分号隔开的就是对应于7个分类层次的结果，后续以分号切割之后统计不同列的结果即可。<br>很自然的我们想到爬虫，其搜索接口为<a href="https://www.ncbi.nlm.nih.gov/taxonomy/?term=拉丁名（空格以+号连接），如https://www.ncbi.nlm.nih.gov/taxonomy/?term=Acetobacter+aceti，然后对结果页面进行后续解析。但是10k之多的查询量，必然要设置爬取频率，否则就要被NCBI关小黑屋了，考虑时间代价，因此果断放弃。其实，从网上查询的原理也是基于Taxonomy后台的数据库，而这个文件在ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz，可以从解压之后的names.dmp和nodes.dmp文件写代码解析，但是其内容过于妖孽，为了少撸掉点头发，因此先看看网上是否有造好的轮子。" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/taxonomy/?term=拉丁名（空格以+号连接），如https://www.ncbi.nlm.nih.gov/taxonomy/?term=Acetobacter+aceti，然后对结果页面进行后续解析。但是10k之多的查询量，必然要设置爬取频率，否则就要被NCBI关小黑屋了，考虑时间代价，因此果断放弃。其实，从网上查询的原理也是基于Taxonomy后台的数据库，而这个文件在ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz，可以从解压之后的names.dmp和nodes.dmp文件写代码解析，但是其内容过于妖孽，为了少撸掉点头发，因此先看看网上是否有造好的轮子。</a><br><img src="/img/taxonkit_usage2.png" alt="a779d01a5ad056030870717c9834834c.png"><br>果然，有三个工具可以实现，ETE toolkit, taxadb和 TaxonKit，这里选择最近发表的TaxonKit，优势在于其直接基于names.dmp和nodes.dmp文件的解析，本地搜索速度块，尤其是大批量的查找和格式转换，另外使用也极简单。<br><img src="/img/taxonkit_usage3.png" alt="b3fdb657d91fc76b4cce0794a9133157.png"><br> <a href="http://dx.doi.org/10.1101/513523" target="_blank" rel="noopener">TaxonKit paper</a><br>相比于另外两种工具，TaxonKit在处理大批量数据时更快，占用内存也可接受</p><h1 id="taxonkit-概述"><a href="#taxonkit-概述" class="headerlink" title="taxonkit 概述"></a>taxonkit 概述</h1><p>说完废话，进入今天的主题，说说TaxonKit这个工具的使用。<br>TaxonKit是处理NCBI Taxonomy数据库中结构性数据的良心工具，19年1月在bioRxiv上online，作者Wei Shen, Jie Xiong，隶属于Department of ClinicalLaboratory, General Hospital of Western Theater Command，特地查了一下，原来是位于成都的中国人民解放军西部战区总医院（好牛的感觉），看来生信真是无处不在。<br><img src="/img/taxonkit_usage4.png" alt="50ba3f6f06f1bd5a6af882128668bbdb.png"><br><img src="/img/taxonkit_usage5.png" alt="e8237772973853ffcfd38f570c47f371.png"><br>它是Go语言编写的，可以在Windows，Linux和Mac OS X运行，直接使用NCBI Taxonomy的数据（需手动下载）而无需构建本地数据库。</p><h2 id="taxonkit安装"><a href="#taxonkit安装" class="headerlink" title="taxonkit安装"></a>taxonkit安装</h2><p>选择对应系统的版本安装，推荐conda安装。详见<a href="https://github.com/shenwei356/taxonkit" target="_blank" rel="noopener">https://github.com/shenwei356/taxonkit</a><br>conda安装如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda taxonkit </span><br><span class="line">``` </span><br><span class="line">## 下载依赖数据</span><br><span class="line">下载NCBI taxonomy数据库的taxdump.tar.gz文件，解压后将names.dmp和 nodes.dmp拷贝到家目录下的.taxonkit目录下。</span><br><span class="line">```bash</span><br><span class="line">wget -c ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz </span><br><span class="line">tar -zxvf taxdump.tar.gz</span><br><span class="line">mkdir -p $HOME/.taxonkit</span><br><span class="line">cp names.dmp nodes.dmp $HOME/.taxonkit</span><br></pre></td></tr></table></figure></p><p>确认文件完整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT]$ ll -h  ~/.taxonkit/</span><br></pre></td></tr></table></figure></p><p>total 155494<br>-rw-r–r–    1 xx    UsersGrp  169.3M Mar 18 16:07 names.dmp<br>-rw-r–r–    1 xx    UsersGrp  134.4M Mar 18 16:07 nodes.dmp<br>配置完成，开始使用。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] taxonkit --help</span><br><span class="line">```    </span><br><span class="line">   Usage:</span><br><span class="line">  taxonkit [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  genautocomplete generate shell autocompletion script</span><br><span class="line">  help            Help about any command</span><br><span class="line">  lineage         query lineage of given taxids</span><br><span class="line">  list            list taxon tree of given taxids</span><br><span class="line">  name2taxid      query taxid by taxon scientific name</span><br><span class="line">  reformat        reformat lineage</span><br><span class="line">  version         print version information and check for update</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --data-dir string   directory containing nodes.dmp and names.dmp (default &quot;/home/xx/.taxonkit&quot;)</span><br><span class="line">  -h, --help              help for taxonkit</span><br><span class="line">      --line-buffered     use line buffering on output, i.e., immediately writing to stdin/file for every</span><br><span class="line">  -o, --out-file string   out file (&quot;-&quot; for stdout, suffix .gz for gzipped out) (default &quot;-&quot;)</span><br><span class="line">  -j, --threads int       number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)</span><br><span class="line">      --verbose           print verbose information</span><br><span class="line">Use &quot;taxonkit [command] --help&quot; for more information about a command.</span><br><span class="line"></span><br><span class="line">taxonkit按照功能分成不同的子命令，其中最主要的功能包括4块：</span><br><span class="line">1）列出给定taxonomy id(taxid)的子分类树：list</span><br><span class="line">2）从taxid获取完整谱系：lineage</span><br><span class="line">3）重新构造谱系的格式：reformat</span><br><span class="line">4）通过物种拉丁名查询taxid：name2taxid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1） 列出给定taxonomy id(taxid)的子分类树</span><br><span class="line">```    </span><br><span class="line">[NeptuneYT$] taxonkit list --help   #查看list子命令使用方法</span><br></pre></td></tr></table></figure><p>list taxon tree of given taxids</p><p>Usage:<br>  taxonkit list [flags]</p><p>Flags:<br>  -h, –help            help for list<br>      –ids string      taxid(s), multiple values should be separated by comma<br>      –indent string   indent (default “  “)<br>      –json            output in JSON format. you can save the result in file with suffix “.json” and open with modern text editor<br>      –show-name       output scientific name<br>      –show-rank       output rank</p><p>Global Flags:<br>      –data-dir string   directory containing nodes.dmp and names.dmp (default “/home/xx/.taxonkit”)<br>      –line-buffered     use line buffering on output, i.e., immediately writing to stdin/file for every line of output<br>  -o, –out-file string   out file (“-“ for stdout, suffix .gz for gzipped out) (default “-“)<br>  -j, –threads int       number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)<br>      –verbose           print verbose information<br>实例：<br>给定taxid：9606和10090<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] taxonkit list --ids 9606,10090 --show-name  --show-rank -j 2</span><br></pre></td></tr></table></figure></p><p>#–ids 给定的taxid，多个以英文逗号分割</p><p>#–show-name    输出科学命名</p><p>#–show-rank    输出分类等级</p><p>#-j 线程数，默认是2<br>9606 [species] Homo sapiens<br>  63221 [subspecies] Homo sapiens neanderthalensis<br>  741158 [subspecies] Homo sapiens subsp. ‘Denisova’</p><p>10090 [species] Mus musculus<br>  10091 [subspecies] Mus musculus castaneus<br>  10092 [subspecies] Mus musculus domesticus<br>  35531 [subspecies] Mus musculus bactrianus<br>  39442 [subspecies] Mus musculus musculus<br>  46456 [subspecies] Mus musculus wagneri<br>  57486 [subspecies] Mus musculus molossinus<br>  80274 [subspecies] Mus musculus gentilulus<br>  116058 [subspecies] Mus musculus brevirostris<br>  179238 [subspecies] Mus musculus homourus<br>  477815 [subspecies] Mus musculus musculus x M. m. domesticus<br>  477816 [subspecies] Mus musculus musculus x M. m. castaneus<br>  947985 [subspecies] Mus musculus albula<br>  1266728 [subspecies] Mus musculus domesticus x M. m. molossinus<br>  1385377 [subspecies] Mus musculus gansuensis<br>  1643390 [subspecies] Mus musculus helgolandicus<br>  1879032 [subspecies] Mus musculus isatissus</p><h3 id="2）从taxid获取完整谱系"><a href="#2）从taxid获取完整谱系" class="headerlink" title="2）从taxid获取完整谱系"></a>2）从taxid获取完整谱系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] echo 9606|taxonkit lineage  -d &quot;-&quot; -t -r</span><br></pre></td></tr></table></figure><p> #-d 输出谱系树分割符，默认分号</p><p> #-t 显示包含taxid的谱系树</p><p> #-r 显示给定taxid的分类等级</p><p>9606    cellular organisms-Eukaryota-Opisthokonta-Metazoa-Eumetazoa-Bilateria-Deuterostomia-Chordata-Craniata-Vertebrata-Gnathostomata-Teleostomi-Euteleostomi-Sarcopterygii\<br>-Dipnotetrapodomorpha-Tetrapoda-Amniota-Mammalia-Theria-Eutheria-Boreoeutheria-Euarchontoglires-Primates-Haplorrhini-Simiiformes-Catarrhini-Hominoidea-Hominidae-Homininae-Homo\<br>-Homo sapiens      131567-2759-33154-33208-6072-33213-33511-7711-89593-7742-7776-117570-117571-8287-1338369-32523-32524-40674-32525-9347-1437010-314146-9443-376913-314293-9526-\<br>314295-9604-207598-9605-9606   species</p><h3 id="3）重新构造谱系的格式"><a href="#3）重新构造谱系的格式" class="headerlink" title="3）重新构造谱系的格式"></a>3）重新构造谱系的格式</h3><p>上一步通过taxid提取的谱系信息复杂，往往需要根据我们的需求重新格式化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] echo 9606|taxonkit lineage |taxonkit reformat</span><br></pre></td></tr></table></figure></p><p>9606    cellular organisms;Eukaryota;Opisthokonta;Metazoa;Eumetazoa;Bilateria;Deuterostomia;Chordata;Craniata;Vertebrata;Gnathostomata;Teleostomi;Euteleostomi;Sarcopterygii;\<br>Dipnotetrapodomorpha;Tetrapoda;Amniota;Mammalia;Theria;Eutheria;Boreoeutheria;Euarchontoglires;Primates;Haplorrhini;Simiiformes;Catarrhini;Hominoidea;Hominidae;Homininae;Homo;\<br>Homo sapiens      Eukaryota;Chordata;Mammalia;Primates;Hominidae;Homo;Homo sapiens<br>输出结果的第三列就是重新格式化的结果，默认是(“{k};{p};{c};{o};{f};{g};{s}”)7个水平。<br>查询给定taxid9606的谱系，并按照门：科；属的格式输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] echo 9606|taxonkit lineage |taxonkit reformat -f &quot;&#123;p&#125;:&#123;f&#125;;&#123;s&#125;&quot; |cut -f3</span><br></pre></td></tr></table></figure></p><p> #{}内是分类等级，大括号之间是输出的连接符<br>Chordata:Hominidae;Homo sapiens</p><h3 id="4）通过物种拉丁名查询taxid：name2taxid"><a href="#4）通过物种拉丁名查询taxid：name2taxid" class="headerlink" title="4）通过物种拉丁名查询taxid：name2taxid"></a>4）通过物种拉丁名查询taxid：name2taxid</h3><p>按人的拉丁名查询taxid<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] echo &quot;Homo sapiens&quot; |taxonkit name2taxid</span><br></pre></td></tr></table></figure></p><p>Homo sapiens    9606<br>批量查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] head scientific_name.txt |taxonkit name2taxid --show-rank</span><br></pre></td></tr></table></figure></p><p>Abiotrophia defectiva   46125   species<br>Abiotrophia sp. 76631   species<br>Absiella dolichum       31971   species<br>Acaryochloris marina    155978  species<br>Acetanaerobacterium sp.<br>Acetivibrio cellulolyticus      35830   species<br>Acetoanaerobium noterae 745369  species<br>Acetoanaerobium sticklandii     1511    species<br>Acetobacter aceti       435     species<br>Acetobacter ghanensis   431306  species</p><h1 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h1><p>基于Taxonkit上述用法，回到之前的问题就好解决了<br>1.将scientific name先转化成taxid，便于查找lineage<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time taxonkit name2taxid  scientific_name.txt &gt;scientific_name_taxid.txt &amp;</span><br><span class="line">awk -F<span class="string">"\t"</span> <span class="string">'$2!=""&#123;print $2&#125;'</span>  scientific_name.txt &gt;find_taxid.txt  <span class="comment">#去掉未查到的，即空值</span></span><br><span class="line">awk -F<span class="string">"\t"</span> <span class="string">'$2==""'</span>  scientific_name_taxid.txt &gt;NotFindName.txt <span class="comment">#输出未查到物种名</span></span><br><span class="line">awk -F<span class="string">"\t"</span> <span class="string">'BEGIN&#123;OFS="\t";print "findTaxid\tNull\tTotal"&#125;&#123;$2!=""?taxid++:null++&#125;END&#123;print taxid,null,taxid+null&#125;'</span> \</span><br><span class="line">scientific_name_taxid.txt |column -t <span class="comment">#统计查找到的和未查到的数量</span></span><br></pre></td></tr></table></figure></p><p>real    0m6.279s<br>findTaxid  Null  Total<br>9606       541   10147</p><p>可以看到，查询速度相当之快。<br>由于待批量查询的物种名不是规范的拉丁名称，导致出现两个问题，一是输入的list是10146个,转换id后（找到和未找到）的行数却增加了1个，统计之后发现是同一个物种名有两个taxid；二是没找到的高达541个！！！为了说明完整的处理过程，541个后面再说。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$]$ awk -F<span class="string">"\t"</span> <span class="string">'&#123;print $1&#125;'</span> scientific_name_taxid.txt |sort |uniq -d</span><br></pre></td></tr></table></figure></p><p>Deinococcus soli<br>手工查询发现是两个种，但是根据部分拉丁名Deinococcus soli可以查到俩taxid我也是醉了。<br><img src="/img/taxonkit_usage6.png" alt="2ddde788a6b5337cc8d843678c18b043.png"></p><p>2.查找lineage<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] time taxonkit lineage find_taxid.txt &gt;lineage.txt&amp;</span><br></pre></td></tr></table></figure></p><p>real    0m7.860s<br>3.重新格式化lineage<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] time taxonkit reformat lineage.txt|cut -f3 &gt;newformat.txt&amp;</span><br></pre></td></tr></table></figure></p><p>real    0m11.465s<br>结果：<br><img src="/img/taxonkit_usage7.png" alt="a5b75e8f601a793caab21771ee9d2630.png"><br>现在就按照界门纲目科属种的层次变成整齐划一的格式了，通过简单处理即可统计不同层次的物种数量和分布，首先构建一个用于循环处理的分类标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] cat tag.txt</span><br></pre></td></tr></table></figure></p><p>1       k<br>2       p<br>3       c<br>4       o<br>5       f<br>6       g<br>7       s<br>详细的物种分类层次数量统计：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] cat tag.txt|<span class="keyword">while</span> <span class="built_in">read</span> num lev;<span class="keyword">do</span>  awk -v v=<span class="variable">$num</span> -F<span class="string">";"</span> <span class="string">'&#123;print $v&#125;'</span> newformat.txt|sort |uniq -c|sort -nr \</span><br><span class="line">|awk -v v=<span class="variable">$lev</span> <span class="string">'&#123;print v"\t"$0&#125;'</span> |awk <span class="string">'$3!=""'</span>;<span class="keyword">done</span> &gt;detail_taxonomy_range.txt</span><br><span class="line">[NeptuneYT$] head detail_taxonomy_range.txt</span><br></pre></td></tr></table></figure></p><p>k          6722 Bacteria<br>k             4 Eukaryota<br>p          2682 Proteobacteria<br>p          1390 Firmicutes<br>p          1099 Actinobacteria<br>p           729 Bacteroidetes<br>p           136 Tenericutes<br>p            86 Spirochaetes<br>p            85 Cyanobacteria<br>p            40 Deinococcus-Thermus</p><p>按7个类别统计数量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NeptuneYT$] cat tag.txt|<span class="keyword">while</span> <span class="built_in">read</span> index level;<span class="keyword">do</span> num=$(awk -v v=<span class="variable">$index</span> -F<span class="string">";"</span> <span class="string">'&#123;print $v&#125;'</span> newformat.txt|sort |uniq \</span><br><span class="line">|wc -l);<span class="built_in">printf</span>  <span class="string">"<span class="variable">$&#123;level&#125;</span>\t<span class="variable">$&#123;num&#125;</span>\n"</span>;<span class="keyword">done</span> |tee taxonomy_stat.txt</span><br></pre></td></tr></table></figure></p><p>k       2<br>p       118<br>c       82<br>o       181<br>f       401<br>g       1824<br>s       6519</p><p>简单画个图瞅瞅：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data&lt;-read.table(<span class="string">'taxonomy_stat.txt'</span>)</span><br><span class="line"><span class="keyword">library</span>(<span class="string">'ggplot2'</span>)</span><br><span class="line">ggplot(data,aes(reorder(V1,-V2),V2,fill=V1))+geom_bar(stat=<span class="string">'identity'</span>)+xlab(<span class="string">'Taxonomy level'</span>)+ylab(<span class="string">'Numbers'</span>)+geom_text(aes(label=V2),position=position_dodge(<span class="number">.9</span>),vjust=-<span class="number">1.5</span>)\</span><br><span class="line">+theme(text=element_text(size=<span class="number">16</span>,family=<span class="string">'Times New Roman'</span>,face=<span class="string">'bold'</span>))+labs(fill=<span class="string">'level'</span>)</span><br></pre></td></tr></table></figure></p><p> <img src="/img/taxonkit_usage8.png" alt="7a4bd388c517c803b8abe18473d705c7.png"></p><h2 id="541个肿么办？"><a href="#541个肿么办？" class="headerlink" title="541个肿么办？"></a>541个肿么办？</h2><p>首先看看没有找到的541个输入物种名长啥样：<br>Bacillus sp.<br>[Bacillus thuringiensis]<br>bacteria symbiont<br>Bacteriovorax sp.<br>bacterium 42 11<br>bacterium BRH c32<br>bacterium Candidatus<br>bacterium CG06 land 8 20 14 3 00 33 50<br>bacterium CG09 39 24<br>bacterium CG1 02 42 9<br>…<br>这个物种list是师妹们给的，实在太好（yao）看(nie)可了，拷问了一遍奈何就只有这样的查询list，那就只能手工挑了几个去网页上查了，发现没有找到taxid的原因包括：<br>1）出现多个搜索结果：原物种名Acaryochloris sp.，搜到的拉丁名：Acaryochloris sp. A4cAcaryochloris marinaAsterochloris sp. DA2Asterochloris sp. 101Asterochloris sp. 103<br>2）截短名称：原物种名Acetothermia bacterium，搜到结果：Candidatus Acetothermia bacterium<br>3）多加中括号：[Bacillus thuringiensis]<br>4）没有下划线：bacterium 42 11，搜到结果：bacterium 42_11<br>针对多加中括号和没有下划线的问题，可以先处理一下，其他的就只能手工查了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -e <span class="string">"s/\[//g;s/\]//g"</span>   NotFindName.txt &gt;bracket_minus_name.txt <span class="comment">#minus all bracket</span></span><br><span class="line">awk <span class="string">'&#123;filed1=$1;$1="";sub(/ /,"");gsub(/ /,"_");print filed1,$0&#125;'</span>  NotFindName.txt  &gt;underline_plus_name.txt <span class="comment">#plus all filed of split underline except first one</span></span><br></pre></td></tr></table></figure></p><p>将后面查到的taxid加到之前的taxid list再按之前的流程跑一遍即可，实在查不到的那就手工吧。（此时配乐起~“这是自由的感觉，鼠标咔哒咔哒点击这些可爱的物种名称，<br>凭着一颗永不哭泣勇敢的心”）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/shenwei356/taxonkit" target="_blank" rel="noopener">taxonkit github</a><br><a href="https://bioinf.shenwei.me/taxonkit/usage/" target="_blank" rel="noopener">taxonkit usage</a><br><a href="http://dx.doi.org/10.1101/513523" target="_blank" rel="noopener">taxonkit paper</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-xJYhtUKW&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;28287132&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
&lt;h1 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;在做宏基因组分析时，通过基因注释得到一个包含10k之多种微生物物种名list(scientific name)，现在想统计这些微生物分属哪些分类水平（界门纲目科属种）。&lt;br&gt;这就是本篇推送想解决的问题，10000多种微生物的拉丁名称示例如下：&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="bioinformatics" scheme="http://yoursite.com/categories/bioinformatics/"/>
    
    
      <category term="taxonomy classfication" scheme="http://yoursite.com/tags/taxonomy-classfication/"/>
    
  </entry>
  
</feed>
